[0m[[0m[0mdebug[0m] [0m[0m> Exec(collectAnalyses, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Processing event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Compile / collectAnalyses[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: Signal, check cycles: false, forcegc: true[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: initialized: JsonRpcNotificationMessage(2.0, initialized, {})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/DeV/ScalaProjects/friends/src/main/scala/FriendsByAge.scala","languageId":"scala","version":1,"text":"package spark3vscode\n\nimport org.apache.spark._\nimport org.apache.spark.SparkContext._\nimport org.apache.log4j._\n\n/** Compute the average number of friends by age in a social network. */\nobject FriendsByAge {\n  \n  /** A function that splits a line of input into (age, numFriends) tuples. */\n  def parseLine(line: String) = {\n      // Split by commas\n      val fields = line.split(\",\")\n      // Extract the age and numFriends fields, and convert to integers\n      val age = fields(2).toInt\n      val numFriends = fields(3).toInt\n      // Create a tuple that is our result.\n      (age, numFriends)\n  }\n  \n  /** Our main function where the action happens */\n  def main(args: Array[String]) {\n   \n    // Set the log level to only print errors\n    Logger.getLogger(\"org\").setLevel(Level.ERROR)\n        \n    // Create a SparkContext using every core of the local machine\n    val sc = new SparkContext(\"local[*]\", \"FriendsByAge\")\n  \n    // Load each line of the source data into an RDD\n    val lines = sc.textFile(\"../fakefriends.csv\")\n    \n    // Use our parseLines function to convert to (age, numFriends) tuples\n    val rdd = lines.map(parseLine)\n    \n    // Lots going on here...\n    // We are starting with an RDD of form (age, numFriends) where age is the KEY and numFriends is the VALUE\n    // We use mapValues to convert each numFriends value to a tuple of (numFriends, 1)\n    // Then we use reduceByKey to sum up the total numFriends and total instances for each age, by\n    // adding together all the numFriends values and 1's respectively.\n    val totalsByAge = rdd.reduceByKey(_+_)\n    \n    // So now we have tuples of (age, (totalFriends, totalInstances))\n    // To compute the average we divide totalFriends / totalInstances for each age.\n    val averagesByAge = rdd.mapValues(v=>(v,1)).reduceByKey((x,y)=>(x._1 + y._1, x._2 + y._2)).mapValues{\n      case (numFriends,numPeople) => numFriends/numPeople\n    } //mapValues(p=>p._1/p._2)\n    \n    // Collect the results from the RDD (This kicks off computing the DAG and actually executes the job)\n    val results = averagesByAge.collect()\n    \n    // Sort and print the final results.\n    results.sorted.foreach(println)\n  }\n    \n}\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0manalysis location (C:\DeV\ScalaProjects\friends\target\scala-2.13\zinc\inc_compile_2.13.zip,true)[0m
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 3 s, completed 03-Apr-2023, 8:31:07 PM[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Done event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(shell, None, None)[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled request received: shutdown: JsonRpcRequestMessage(2.0, â™¨1, shutdown, null})[0m
