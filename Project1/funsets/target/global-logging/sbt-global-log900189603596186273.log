[0m[[0m[0mdebug[0m] [0m[0m> Exec(collectAnalyses, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Processing event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: initialized: JsonRpcNotificationMessage(2.0, initialized, {})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/DeV/funsets/src/main/scala/funsets/FunSets.scala","languageId":"scala","version":1,"text":"package funsets\n\nimport common._\n\n/**\n * 2. Purely Functional Sets.\n */\nobject FunSets {\n  /**\n   * We represent a set by its characteristic function, i.e.\n   * its `contains` predicate.\n   */\n  type IntSet = Int => Boolean\n\n  /**\n   * Indicates whether a set contains a given element.\n   */\n  def contains(s: IntSet, elem: Int): Boolean = s(elem)\n\n  /**\n   * Returns the set of the one given element.\n   */\n  def singletonSet(elem: Int): IntSet = (x: Int) => x == elem\n\n  /**\n   * Returns the union of the two given sets,\n   * the sets of all elements that are in either `s` or `t`.\n   */\n  def union(s: IntSet, t: IntSet): IntSet = (x:Int) => s(x) || t(x)\n  /**\n   * Returns the intersection of the two given sets,\n   * the set of all elements that are both in `s` and `t`.\n   */\n  def intersect(s: IntSet, t: IntSet): IntSet = (x:Int) => s(x) && t(x)\n  /**\n   * Returns the difference of the two given sets,\n   * the set of all elements of `s` that are not in `t`.\n   */\n  def diff(s: IntSet, t: IntSet): IntSet = (x:Int) => s(x) && !t(x)\n\n  /**\n   * Returns the subset of `s` for which `p` holds.\n   */\n  def filter(s: IntSet, p: Int => Boolean): IntSet = (x:Int) => s(x) && p(x)\n\n  /**\n   * The bounds for `forall` and `exists` are +/- 1000.\n   */\n  val bound = 1000\n\n  /**\n   * Returns whether all bounded integers within `s` satisfy `p`.\n   */\n  def forall(s: IntSet, p: Int => Boolean): Boolean = {\n    \n    def forall_aux(a: Int): Boolean = {\n      if (a > bound) true\n      else if (contains(s,a) && !p(a)) false\n      else forall_aux(a+1)\n    }\n    \n    forall_aux(-bound)\n  }\n\n  /**\n   * Returns whether there exists a bounded integer within `s`\n   * that satisfies `p`.\n   */\n  def exists(s: IntSet, p: Int => Boolean): Boolean = {\n    def exists_aux(a: Int): Boolean = {\n    if (a > bound) false\n    else if (contains(s, a) && p(a)) true\n    else exists_aux(a + 1)\n  }\n\n  exists_aux(-bound)\n  }\n\n  /**\n   * Returns a set transformed by applying `f` to each element of `s`.\n   */\n  def map(s: IntSet, f: Int => Int): IntSet = (x: Int) => s(f(x))\n\n  /**\n   * Displays the contents of a set\n   */\n  def toString(s: IntSet): String = {\n    val xs = for (i <- -bound to bound if contains(s, i)) yield i\n    xs.mkString(\"{\", \",\", \"}\")\n  }\n\n  /**\n   * Prints the contents of a set on the console.\n   */\n  def printSet(s: IntSet) = {\n    println(toString(s))\n  }\n}\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/DeV/funsets/src/test/scala/funsets/FunSetsSuite.scala","languageId":"scala","version":1,"text":"package funsets\n\nimport org.scalatest.funsuite.AnyFunSuite\n\nclass FunSetsSuite extends AnyFunSuite {\n  \n  import FunSets._\n\n  /**\n   * Link to the scaladoc - very clear and detailed tutorial of AnyFunSuite:\n   *\n   * https://www.scalatest.org/scaladoc/3.2.15/org/scalatest/funsuite/AnyFunSuite.html\n   *\n   * Operators\n   *  - test\n   *  - ignore\n   *  - pending\n   */\n\n  /**\n   * Tests are written using the \"test\" operator and the \"assert\" method.\n   */\n  test(\"string take\") {\n    val message = \"hello, world\"\n    assert(message.take(5) == \"hello\")\n  }\n\n  /**\n   * For ScalaTest tests, there exists a special equality operator \"===\" that\n   * can be used inside \"assert\". If the assertion fails, the two values will\n   * be printed in the error message. Otherwise, when using \"==\", the test\n   * error message will only say \"assertion failed\", without showing the values.\n   *\n   * Try it out! Change the values so that the assertion fails, and look at the\n   * error message.\n   */\n  test(\"adding ints\") {\n    assert(1 + 2 === 3)\n  }\n  \n  test(\"contains is implemented\") {\n    assert(contains(x => true, 100))\n  }\n  \n  /**\n   * When writing tests, one would often like to re-use certain values for multiple\n   * tests. For instance, we would like to create an Int-set and have multiple test\n   * about it.\n   * \n   * Instead of copy-pasting the code for creating the set into every test, we can\n   * store it in the test class using a val:\n   * \n   *   val s1 = singletonSet(1)\n   * \n   * However, what happens if the method \"singletonSet\" has a bug and crashes? Then\n   * the test methods are not even executed, because creating an instance of the\n   * test class fails!\n   * \n   * Therefore, we put the shared values into a separate trait (traits are like\n   * abstract classes), and create an instance inside each test method.\n   * \n   */\n\n  trait TestSets {\n    val s1 = singletonSet(1)\n    val s2 = singletonSet(2)\n    val s3 = singletonSet(3)\n  }\n\n  /**\n   * This test is currently disabled (by using \"ignore\") because the method\n   * \"singletonSet\" is not yet implemented and the test would fail.\n   * \n   * Once you finish your implementation of \"singletonSet\", exchange the\n   * function \"ignore\" by \"test\".\n   */\n  test(\"singletonSet(1) contains 1\") {\n    \n    /**\n     * We create a new instance of the \"TestSets\" trait, this gives us access\n     * to the values \"s1\" to \"s3\". \n     */\n    new TestSets {\n      /**\n       * The string argument of \"assert\" is a message that is printed in case\n       * the test fails. This helps identifying which assertion failed.\n       */\n      assert(contains(s1, 1), \"Singleton\")\n    }\n  }\n\n  test(\"union contains all elements\") {\n    new TestSets {\n      val s = union(s1, s2)\n      assert(contains(s, 1), \"Union 1\")\n      assert(contains(s, 2), \"Union 2\")\n      assert(!contains(s, 3), \"Union 3\")\n    }\n  }\n}\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Compile / collectAnalyses[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: Signal, check cycles: false, forcegc: true[0m
[0m[[0m[0mdebug[0m] [0m[0manalysis location (C:\DeV\funsets\target\scala-2.13\zinc\inc_compile_2.13.zip,true)[0m
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 0 s, completed 11-Mar-2023, 4:18:27 PM[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Done event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(shell, None, None)[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled request received: shutdown: JsonRpcRequestMessage(2.0, â™¨1, shutdown, null})[0m
