[0m[[0m[0mdebug[0m] [0m[0m> Exec(collectAnalyses, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Processing event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Compile / collectAnalyses[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: initialized: JsonRpcNotificationMessage(2.0, initialized, {})[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: Signal, check cycles: false, forcegc: true[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/DeV/oosets/src/main/scala/oosets/TweetSet.scala","languageId":"scala","version":1,"text":"package objsets\n\nimport common._\nimport TweetReader._\n\n/**\n * A class to represent tweets.\n */\nclass Tweet(val user: String, val text: String, val retweets: Int) {\n  override def toString: String =\n    \"User: \" + user + \"\\n\" +\n    \"Text: \" + text + \" [\" + retweets + \"]\"\n}\n\n/**\n * This represents a set of objects of type `Tweet` in the form of a binary search\n * tree. Every branch in the tree has two children (two `TweetSet`s). There is an\n * invariant which always holds: for every branch `b`, all elements in the left\n * subtree are smaller than the tweet at `b`. The elements in the right subtree are\n * larger.\n *\n * Note that the above structure requires us to be able to compare two tweets (we\n * need to be able to say which of two tweets is larger, or if they are equal). In\n * this implementation, the equality / order of tweets is based on the tweet's text\n * (see `def incl`). Hence, a `TweetSet` could not contain two tweets with the same\n * text from different users.\n *\n *\n * The advantage of representing sets as binary search trees is that the elements\n * of the set can be found quickly. If you want to learn more you can take a look\n * at the Wikipedia page [1], but this is not necessary in order to solve this\n * assignment.\n *\n * [1] http://en.wikipedia.org/wiki/Binary_search_tree\n */\nabstract class TweetSet { \n\n  /**\n   * This method takes a predicate and returns a subset of all the elements\n   * in the original set for which the predicate is true.\n   *\n   * Question: Can we implment this method here, or should it remain abstract\n   * and be implemented in the subclasses?\n   */\n  def filter(p: Tweet => Boolean): TweetSet = filterAcc(p, new Empty)\n\n  /**\n   * This is a helper method for `filter` that propagetes the accumulated tweets.\n   */\n  def filterAcc(p: Tweet => Boolean, acc: TweetSet): TweetSet\n\n  /**\n   * Returns a new `TweetSet` that is the union of `TweetSet`s `this` and `that`.\n   *\n   * Question: Should we implment this method here, or should it remain abstract\n   * and be implemented in the subclasses?\n   */\n   def union(that: TweetSet): TweetSet = ???\n\n  /**\n   * Returns the tweet from this set which has the greatest retweet count.\n   *\n   * Calling `mostRetweeted` on an empty set should throw an exception of\n   * type `java.util.NoSuchElementException`.\n   *\n   * Question: Should we implment this method here, or should it remain abstract\n   * and be implemented in the subclasses?\n   */\n  def mostRetweeted: Tweet = ???\n\n  /**\n   * Returns a list containing all tweets of this set, sorted by retweet count\n   * in descending order. In other words, the head of the resulting list should\n   * have the highest retweet count.\n   *\n   * Hint: the method `remove` on TweetSet will be very useful.\n   * Question: Should we implment this method here, or should it remain abstract\n   * and be implemented in the subclasses?\n   */\n  def descendingByRetweet: TweetList = ???\n\n\n  /**\n   * The following methods are already implemented\n   */\n\n  /**\n   * Returns a new `TweetSet` which contains all elements of this set, and the\n   * the new element `tweet` in case it does not already exist in this set.\n   *\n   * If `this.contains(tweet)`, the current set is returned.\n   */\n  def incl(tweet: Tweet): TweetSet\n\n  /**\n   * Returns a new `TweetSet` which excludes `tweet`.\n   */\n  def remove(tweet: Tweet): TweetSet\n\n  /**\n   * Tests if `tweet` exists in this `TweetSet`.\n   */\n  def contains(tweet: Tweet): Boolean\n\n  /**\n   * This method takes a function and applies it to every element in the set.\n   */\n  def foreach(f: Tweet => Unit): Unit\n}\n\nclass Empty extends TweetSet {\n\n  override def descendingByRetweet: TweetList = Nil\n  override def mostRetweeted: Tweet = throw new java.util.NoSuchElementException\n\n  def filterAcc(p: Tweet => Boolean, acc: TweetSet): TweetSet = acc\n\n\n  /**\n   * The following methods are already implemented\n   */\n\n  override def union(that: TweetSet): TweetSet = that\n  \n  def contains(tweet: Tweet): Boolean = false\n\n  def incl(tweet: Tweet): TweetSet = new NonEmpty(tweet, new Empty, new Empty)\n\n  def remove(tweet: Tweet): TweetSet = this\n\n  def foreach(f: Tweet => Unit): Unit = ()\n} \n\nclass NonEmpty(elem: Tweet, left: TweetSet, right: TweetSet) extends TweetSet {\n\n  override def descendingByRetweet: TweetList = {\n  val mostRetweets = mostRetweeted\n   new Cons(mostRetweets, remove(mostRetweets).descendingByRetweet)\n}\n\n  override def mostRetweeted: Tweet = {\n\n    val LM = try{\n      left.mostRetweeted\n    }catch{\n      case _: NoSuchElementException => elem\n    \n    }\n\n    val RM = try{\n      right.mostRetweeted\n    }catch{\n      case _: NoSuchElementException => elem\n    \n    }\n    if (LM.retweets >= RM.retweets) {\n      if (LM.retweets >= elem.retweets) LM else elem\n    } else {\n      if (RM.retweets >= elem.retweets) RM else elem\n      }\n    }\n  \n\n  def filterAcc(p: Tweet => Boolean, acc: TweetSet): TweetSet = {\n\n    if (p(elem)){\n        left.filterAcc(p,acc incl (elem)) union right.filterAcc(p,acc)\n    }\n    else{\n        left.filterAcc(p, acc) union right.filterAcc(p,acc)\n    }\n  }\n\n  override def union(that: TweetSet): TweetSet = ((left union right) union that) incl elem\n\n\n  /**\n   * The following methods are already implemented\n   */\n\n  def contains(x: Tweet): Boolean =\n    if (x.text < elem.text) left.contains(x)\n    else if (elem.text < x.text) right.contains(x)\n    else true\n\n  def incl(x: Tweet): TweetSet = {\n    if (x.text < elem.text) new NonEmpty(elem, left.incl(x), right)\n    else if (elem.text < x.text) new NonEmpty(elem, left, right.incl(x))\n    else this\n  }\n\n  def remove(tw: Tweet): TweetSet =\n    if (tw.text < elem.text) new NonEmpty(elem, left.remove(tw), right)\n    else if (elem.text < tw.text) new NonEmpty(elem, left, right.remove(tw))\n    else left.union(right)\n\n  def foreach(f: Tweet => Unit): Unit = {\n    f(elem)\n    left.foreach(f)\n    right.foreach(f)\n  }\n}\n\ntrait TweetList {\n  def head: Tweet\n  def tail: TweetList\n  def isEmpty: Boolean\n  def foreach(f: Tweet => Unit): Unit =\n    if (!isEmpty) {\n      f(head)\n      tail.foreach(f)\n    }\n}\n\nobject Nil extends TweetList {\n  def head = throw new java.util.NoSuchElementException(\"head of EmptyList\")\n  def tail = throw new java.util.NoSuchElementException(\"tail of EmptyList\")\n  def isEmpty = true\n}\n\nclass Cons(val head: Tweet, val tail: TweetList) extends TweetList {\n  def isEmpty = false\n}\n\n\nobject  GoogleVsApple {\n  val google = List(\"android\", \"Android\", \"galaxy\", \"Galaxy\", \"nexus\", \"Nexus\")\n  val apple = List(\"ios\", \"iOS\", \"iphone\", \"iPhone\", \"ipad\", \"iPad\")\n\n  val allTweets = TweetReader.allTweets\n  lazy val googleTweets: TweetSet = allTweets.filter(tweet=>google.forall(a=>tweet.text.contains(a)))\n  lazy val appleTweets: TweetSet = allTweets.filter(tweet=>apple.forall(a=>tweet.text.contains(a)))\n\n  /**\n   * A list of all tweets mentioning a keyword from either apple or google,\n   * sorted by the number of retweets.\n   */\n  lazy val trending: TweetList = googleTweets.union(appleTweets).descendingByRetweet\n\n}\n\nobject Main extends App {\n  // Print the trending tweets\n  GoogleVsApple.trending foreach println\n}\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0manalysis location (C:\DeV\oosets\target\scala-2.13\zinc\inc_compile_2.13.zip,true)[0m
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 0 s, completed 25-Mar-2023, 4:45:39 PM[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Done event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(shell, None, None)[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled request received: shutdown: JsonRpcRequestMessage(2.0, â™¨1, shutdown, null})[0m
